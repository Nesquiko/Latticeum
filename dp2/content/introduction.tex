\chapter{Introduction}

Ethereum, a decentralized blockchain platform launched in 2015, provides a
Turing-complete execution environment for smart contracts and decentralized
applications \cite{ethereumEthereumWhitepaper}. Its modular architecture
comprises a proof-of-stake consensus layer (Gasper \cite{VitalikGasper}) and
an execution layer governed by the Ethereum Virtual Machine (EVM
\cite{ethereumConsensusMechanisms}). A primary challenge for Ethereum is
scalability, as the need for all nodes to validate and re-execute every
transaction limits throughput and can centralize the network by increasing
resource demands.

"Snarkification," the integration of Zero-Knowledge Proofs (ZKPs) like SNARKs,
offers a path to mitigate these scalability issues. Initiatives such as the
'Lean consensus' \cite{LeanConsensus} aim to snarkify consensus, allowing
validators to verify compact proofs instead of entire state components.
Similarly, Zero-Knowledge Ethereum Virtual Machines (ZkEVMs) seek to make EVM
execution provable, enabling nodes to verify block execution via a single
proof. Enshrining a ZkEVM into Ethereum's Layer 1 could further enhance
scalability and simplify the creation of native rollups \cite{NativeRollups}.

Zero-Knowledge proofs allow proving a statement's truth without revealing
underlying information. These statements are about an element membership in NP
language, thus an entire computations can be proven with this primitives, for example
like computations done by the EVM, turning it into a ZkEVM. However,
developing ZkEVMs is challenging due to the EVM's original design: complex
opcodes, large word sizes requiring range proofs, its stack-based nature, and
ZK-unfriendly storage mechanisms. Early solutions utilized recursive proofs to
aggregate computation steps, leading to the first generation of Layer 2
ZkEVMs. Folding schemes further optimized this by compressing instances. The
current trend involves Zero-Knowledge Virtual Machines (ZkVMs), especially
those based on the simpler, register-based RISC-V ISA \cite{RISCV}, which is
more amenable to ZK proof generation.

While many ZKP systems rely on assumptions vulnerable to quantum attacks,
lattice-based cryptography provides a foundation for post-quantum secure ZK
solutions, with security often based on hard problems like SVP or SIS \cite{Ajtai1998}.

This thesis investigates the design and implementation of a RISC-V ZkVM using
lattice-based cryptography. A key application is proving Ethereum block
execution, contributing to the network's scalability and post-quantum
security. This work explores the practical construction of such a system and
aims to assess whether lattice-based cryptography can offer performance
comparable to classical ZKP methods while ensuring quantum resistance.

\section*{Document Structure}

This work is structured as follows. Chapter~\ref{chap:analysis} provides the
necessary background and analysis of the current state of ZkVMs and
lattice-based cryptography. It begins with an overview of Ethereum's consensus
and execution mechanisms~\ref{sec:ethereum}, followed by an analysis of
Snarkification initiatives~\ref{sec:snarkification}. The chapter then examines
ZkEVMs~\ref{sec:zkevm}, discussing the evolution from recursive proofs to modern
folding schemes and RISC-V based ZkVMs. Finally, it introduces lattice-based
cryptography~\ref{sec:lattices}, covering Ajtai commitments and recent
developments in lattice-based zero-knowledge systems.

Chapter~\ref{chap:problem_statement} defines the research gap regarding
post-quantum secure ZkVMs and establishes the specific scientific questions and
objectives that guide the solution design and implementation. It outlines the
problem of the lack of lattice-based RISC-V ZkVM designs and
specifies the feasibility, performance, and long-running computation questions
to be addressed.

Chapter~\ref{chap:design} details the architectural and cryptographic design
of the proposed lattice-based RISC-V ZkVM. It presents the high-level
architecture~\ref{sec:arch} describing the proof lifecycle from Rust code to
succinct argument, specifies the cryptographic primitives~\ref{sec:crypto}
including LatticeFold, SuperSpartan, and Greyhound, and describes the
construction of the RISC-V step circuit~\ref{sec:riscv_circuit} and the
IVC-augmented circuit~\ref{sec:ivc}.

Chapter~\ref{chap:implementation} presents the prototype implementation of the
lattice-based RISC-V ZkVM. It describes the technology stack~\ref{sec:tech_stack}
and implementation details, including the RISC-V emulator, Poseidon2
integration, and circuit synthesis with CCS constraints for the IVC step
commitments.

Chapter~\ref{chap:evaluation} provides an initial evaluation of the implemented
components. It presents baseline performance measurements from the Fibonacci
benchmark on consumer hardware, discusses the limitations of the incomplete
implementation, and addresses the research questions from both design and
implementation perspectives.

Chapter~\ref{chap:conclusion} concludes the work by summarizing the design
and implementation achievements and outlining directions for future work,
including formal verification, LatticeFold+ integration, GPU acceleration, and
lookup incorporation.

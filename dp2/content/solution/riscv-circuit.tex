\section{Designing the RISC-V circuit ($F$)}\label{sec:riscv_circuit}

This section details the construction of the step circuit $F$, which encodes
the transition function of the RISC-V VM according to RISC-V ISA \cite{RISCV}.
The design targets a 32 bit architecture.

\subsection{Field representations and arithmetization}

The target architecture is a 32 bit RISC-V machine. The state of this machine
within the cryptographic proof system is represented by elements from the
Goldilocks field. The Goldilocks prime is defined as $p = 2^{64} - 2^{32} + 1$. Since $p >
2^{32}$, a single field element can losslessly represent any 32 bit register
value or memory address without overflow during standard representation.

The LatticeFold protocol operates over cyclotomic rings. A Goldilocks field
element is mapped into the ring $R_q$ using a Number Theoretic Transform (NTT)
representation, where the base field is a 3rd degree extension of the Goldilocks
field, and the NTT form consists of 8 components.

Arithmetization is the process of converting numbers handled by the VM,
captured in the execution trace, into cyclotomic ring elements over the
Goldilocks field. 

\subsection{State representation}

The execution state at any step $i$ is encapsulated by the tuple $z_i$, which
contains the following components:

\begin{itemize}
    \item \textbf{Program counter ($pc_i$):} A 32 bit integer indicating the address of the next instruction.
    \item \textbf{Registers:} An array of 32 general purpose 32 bit registers.
    \item \textbf{Memory state:} Represented by the root of a Merkle tree covering the machine's RAM.
    \item \textbf{Memory log:} A commitment to the vector of memory operations performed up to step $i$.
\end{itemize}

The initial state $z_0$ serves as a public anchor for the computation. Its
commitment $z_{0\_\text{comm}}$ binds the proof to a specific ELF binary
(represented by a \texttt{code\_comm} Merkle root), the entrypoint, and the
initial zeroed state of memory and registers. All of these values are public,
known to both prover and verifier, this means, they do not have to be recomputed
or constrained by the prover within the circuit.

\subsection{Instruction decoding and execution}

For each step, the circuit $F$ enforces valid transitions between $z_{i-1}$
and $z_i$. This process involves the following constraints:

\begin{enumerate}
    \item \textbf{Fetch:} The circuit verifies that the
		instruction executed corresponds to the value stored at $pc_{i-1}$.
		This is enforced by verifying a Merkle proof against the static
		\texttt{code\_comm} root derived from the ELF binary.

	\item \textbf{Validation:} To ensure that the claimed decoded instruction
		corresponds to exactly one valid instruction, the circuit enforces
		three conditions on the set of selector flags $S = \{z_{\texttt{IS\_ADD}}, z_{\texttt{IS\_MUL}}, \dots\}$:

		\begin{enumerate}
			\item \textbf{Booleanity (are 0 or 1):} $\forall s \in S, s \cdot (1-s) = 0$.

			\item \textbf{Mutual exclusion (only one is 1):} $\sum_{s \in S} s = 1$.

			\item \textbf{\texttt{OPCODE} consistency:} Each instruction word contains a 7 bit
				\texttt{OPCODE}\footnote{E.g. \texttt{0110011} for R type,
				register-to-register, instructions}. To enforce consistency
				between the active selector flag and the instruction, opcode
				bits $z_{\texttt{INSTRUCTION}}[0:7]$ are constrained to
                match the weighted sum of opcode constants:
				\[
					\sum_{s \in S} (s \cdot \texttt{OPCODE}_s) = z_{\texttt{INSTRUCTION}}[0:7]
				\]
				Where $\texttt{OPCODE}_s$ is the corresponding constant to the
				instruction $s$\footnote{\texttt{ADD} and \texttt{SUB} are R type instruction,
				which means, for them $\texttt{OPCODE}_s = 0110011$}.
                Since only one flag $s$ is active, this sum collapses to the
				constant $\texttt{OPCODE}_s$ of the selected instruction.
				
			\item \textbf{\texttt{functX} consistency:}
				Certain instructions need additional fields from their binary format
				to be uniquely decodable. Instruction flags subset of those
				that require \texttt{funct3} is defined as $S_{\texttt{F3}}
				\subset S$ and subset for those that require \texttt{funct7} as
				$S_{\texttt{F7}} \subset S$\footnote{Instruction \texttt{ADD}
				and \texttt{SUB} have the same \texttt{OPCODE} and
				\texttt{funct3}, but their \texttt{funct7} differ}.
				The circuit enforces:
				\[
					\sum_{s \in S_{\texttt{F3}}} s \cdot (z_{\texttt{INSTRUCTION}}[12:14] - \texttt{F3}_s) = 0
				\]
                \[
					\sum_{s \in S_{\texttt{F7}}} s \cdot (z_{\texttt{INSTRUCTION}}[25:31] - \texttt{F7}_s) = 0
				\]
                Instructions that do not require these fields, are not in the
				subsets, and these terms equal to 0.

		\end{enumerate}

	\item \textbf{Range checks:} Based on the decoded instruction, source
		registers ($rs1, rs2$), destination register ($rd$), and/or immediate
		values are checked inside the circuit.
		Register indices must be bounded $rs1, rs2, rd \in [0, 31]$
		and immediate values are constrained to the valid bit width for each
		instruction type.

    \item \textbf{Execution logic:} Based on the decoded instruction, the circuit
		enforces it's semantic logic.

    \item \textbf{State update:} The circuit constrains the output state
		$z_i$. For arithmetic instructions, this involves updating the
		destination register. For branch instructions, it involves updating
		the $pc$.
\end{enumerate}

\subsection{Memory consistency checks}

Memory consistency ensures that a load operation at step $i$ returns the value
written by the most recent store operation to that address. The verification of
the memory consistency is deferred until the end, when all memory access logs
have been collected. Done this way, the circuit inside IVC is less complex
and does not need to keep track of the history of memory accesses in state.

When a load or store instruction is executed:

\begin{enumerate}
    \item \textbf{Operation capture:} The circuit captures the operation,
		which contains the cycle count $i$, the address, the value, and a
		boolean flag indicating a write operation.
    \item \textbf{Log update:} This operation is appended to the memory log,
		and new commitment (from the previous one and the parts of the new memory
		operation) is passed as public input. Within $F$, this new commitment is
		recalculated and compared to the supplied public input.
    \item \textbf{Page validation:} For store operations, the circuit
		additionally verifies a Merkle proof for the memory page being
		modified, calculates the new page root, and updates the memory Merkle
		root in the state $z_i$.
\end{enumerate}

The memory log is not fully verified against the register state at every step.
Instead, the correctness of the read/write history is verified in the final
wrapping SNARK (discussed in subsection \ref{subsec:wrapping_snark}) using
checks described in previous subsection \ref{subsec:memory_check}.

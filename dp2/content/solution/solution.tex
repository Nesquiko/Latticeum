\chapter{Solution Design}\label{chap:design}

This chapter details the architectural and cryptographic design of the
proposed lattice-based RISC-V ZkVM. It is structured to first
establish the system's high-level architecture \ref{sec:arch}, describing the
lifecycle of a proof from high-level Rust code to a finalized succinct
argument. Following this, the specific cryptographic primitives are defined
\ref{sec:crypto}, selecting the LatticeFold folding scheme \cite{LatticeFold}
as the core recursion engine, while identifying Greyhound \cite{Greyhound} as
the necessary wrapping SNARK for final verification. The design then proceeds
to the construction of the RISC-V step circuit $F$ \ref{sec:riscv_circuit},
detailing how 32 bit integer arithmetic is arithmetized into the small fields
required by lattice schemes using CCS \cite{CCS}. Finally, the recursive
composition mechanism $F'$ is defined \ref{sec:recursive_mechanism}, outlining
how IVC \cite{ValiantIVC} is enforced to prove the integrity of long running computations.

\section{High level Architecture}\label{sec:arch}

The proposed system architecture implements a post-quantum ZkVM capable of
proving the correct execution of arbitrary RISC-V programs. The design
leverages IVC to break down the execution of a program into individual steps.
To instantiate IVC a folding scheme LatticeFold \cite{LatticeFold} is used,
which recursively folds steps into a single, constant-sized cryptographic object.

The architecture is designed to support the 32 bit RISC-V instruction set
(specifically the \texttt{rv32imac} extensions). Due to the proof-of-concept
nature of this implementation, a subset of opcodes is supported, sufficient to
test the viability of a lattice-based ZkVM.

\subsection{The ZkVM IVC}

The lifecycle of a proof within this system proceeds through a pipeline of
transformation, execution, and cryptographic accumulation, as illustrated in
Figure \ref{fig:execution_flow}. This workflow is defined by the following stages:


\begin{enumerate}
    \item \textbf{Compilation and loading:} A program written in a high-level
		language (e.g., Rust) is compiled into a standard RISC-V ELF binary.
		This binary is loaded into the ZkVM emulator.
    
    \item \textbf{Execution and trace generation:} The emulator executes the
		program one instruction at a time. For every step $i$, the system
		captures a comprehensive \textit{Execution Trace}. This trace
		encapsulates the exact state transition of the machine.
		Mathematically, the trace for step $i$, denoted as $\mathcal{T}_i$, contains:
    \begin{itemize}
        \item \textbf{Cycle count:} The global step counter.
        \item \textbf{Input state:} The Program Counter ($PC$) and the state of all 32 general-purpose registers before execution.
        \item \textbf{Output state:} The $PC$ and register states after execution.
        \item \textbf{Decoded instruction:} The raw binary instruction broken down into its opcode, operands, and immediate values.
        \item \textbf{Side effects:} A set of flags indicating arithmetic overflows, branching behavior (jump targets), and memory operations (address, value, and read/write flags).
    \end{itemize}

    \item \textbf{Arithmetization and witness generation:} The raw data from
		$\mathcal{T}_i$ is transformed into a vector of lattice field elements
		$\mathbb{Z}_q$. This vector serves as the \textit{witness} for the
		constraint system. The logic verifying the transition from input state
		to output state based on the decoded instruction defines the
		\textbf{Step circuit}, denoted as $F$.

    \item \textbf{Folding (the augmented circuit $F'$):} To achieve
		IVC, the step circuit $F$ is embedded inside a larger augmented
		circuit, $F'$. This circuit is responsible for the recursive logic.
		For a step $i$, $F'$ performs the following operations:
    \begin{enumerate}
        \item \textbf{IVC integrity checks:} It recalculates the commitment to
			the previous step's data, ensuring the chain of computation is
			unbroken. This follows the IVC patterns established in Nova
			\cite{Nova} and HyperNova \cite{HyperNova}.
        \item \textbf{Folding verification:} It constrains the LatticeFold
			verifier. This enforces that the folding of step $i-1$ into the
			running accumulator was performed correctly.
        \item \textbf{Step verification:} It enforces the constraints of $F$,
			guaranteeing that the RISC-V instruction at step $i$ was executed
			correctly according to the ISA.
    \end{enumerate}

    \item \textbf{Memory logging:} If the instruction execution triggers a
		memory operation (load or store), this side effect is captured and
		appended to a global vector of memory operations. Unlike register
		transitions, memory consistency is not fully proven within $F'$;
		instead, it is verified via a deferred memory consistency check after
		the execution concludes.

	\item \textbf{Final wrapping:} Once the program halts, the system holds a
		single folded instance-witness pair (the accumulator). To produce a
		succinct proof suitable for blockchain verification, this large
		lattice-based artifact is wrapped in a final SNARK as depicted in Figure \ref{fig:snark_wrap}. 
		This wrapper utilizes the SuperSpartan IOP \cite{HyperNova} to prove the validity of the folded
		CCS instance, combined with the Greyhound \cite{Greyhound} PCS to
		ensure post-quantum security and succinct verification.
\end{enumerate}

\begin{tikzFigure}
    \begin{tikzpicture}
		\node[dataNode] (rust) {Rust source};
		\node[processNode, right=0.8cm of rust] (compiler) {Compiler\\(LLVM/GCC)};
		\node[dataNode, right=0.8cm of compiler] (elf) {RISC-V\\binary};

		\draw[arrow] (rust) -- (compiler);
		\draw[arrow] (compiler) -- (elf);

		\node[processNode, below=1cm of elf] (vm) {ZkVM\\emulator};
		\draw[arrow] (elf) -- (vm);

		\node[dataNode, below=1cm of vm] (witness) {Witness $w_i$\\($\mathbb{Z}_q$ Matrix)};
		\draw[arrow] (vm) -- node[midway, right] {Exec instruction $i$} (witness);

		\node[processNode, below left=1.5cm and 0.5cm of witness] (stepCircuit) {Step circuit $F$\\ (RISC-V logic)};
		\node[processNode, below=0.5cm of stepCircuit] (ivcChainCheck) {IVC chain\\check};
		\node[processNode, below=0.5cm of ivcChainCheck] (foldVerifier) {LatticeFold\\verifier};

		\node[augmentedFrame, fit=(stepCircuit) (foldVerifier)] (augCircuit) {};
		\node[anchor=south east] at (augCircuit.north east) {\textbf{Augmented circuit $F'$}};

		\node[dataNode, left=1.5cm of augCircuit, yshift=-1.5cm] (accPrev) {Accumulator\\$i-1$};
		\node[dataNode, left=1.5cm of augCircuit] (ivcProofPrev) {Folding proof\\of step $i-1$};
		\node[dataNode, left=1.5cm of augCircuit, yshift=1.5cm] (ivcHPrev) {IVC commitment $h$\\to step $i-1$};

		\node[dataNode, right=1.5cm of augCircuit, yshift=-1.5cm] (accNext) {Accumulator\\$i$};
		\node[dataNode, right=1.5cm of augCircuit] (ivcProofNext) {Folding proof\\of step $i$};
		\node[dataNode, right=1.5cm of augCircuit, yshift=1.5cm] (ivcHNext) {IVC commitment $h$\\to step $i$};

		\draw[arrow] (witness.south) -- (stepCircuit.east);
		\draw[arrow] (accPrev.east) -- (accPrev -| augCircuit.west);
		\draw[arrow] (ivcProofPrev.east) -- (ivcProofPrev -| augCircuit.west);
		\draw[arrow] (ivcHPrev.east) -- (ivcHPrev -| augCircuit.west);

		\draw[arrow] (augCircuit.east) -- (accNext.west);
		\draw[arrow] (augCircuit.east) -- (ivcProofNext.west);
		\draw[arrow] (augCircuit.east) -- (ivcHNext.west);

		\node[dataNode, below=1cm of augCircuit, xshift=0.5cm] (memLog) {Memory\\operations log};
		\draw[dashedArrow] (stepCircuit.west) -- ++(-1.5,-1) -- ++(0,-1.5) -- (memLog.west) node[midway, left] {\scriptsize Memory logs};

		\node[left=0.8cm of ivcProofPrev] (dotsStart) {\Large$\dots$};
		\draw[dashedArrow] (dotsStart) -- (accPrev);
		\draw[dashedArrow] (dotsStart) -- (ivcHPrev);
		\draw[dashedArrow] (dotsStart) -- (ivcProofPrev);

		\node[right=0.8cm of ivcProofNext] (dotsEnd) {\Large$\dots$};
		\draw[dashedArrow] (accNext) -- (dotsEnd);
		\draw[dashedArrow] (ivcHNext) -- (dotsEnd);
		\draw[dashedArrow] (ivcProofNext) -- (dotsEnd);
    \end{tikzpicture}

	\caption{Execution flow of the lattice-based RISC-V ZkVM IVC instantiation.}
	\label{fig:execution_flow}
\end{tikzFigure}

\begin{tikzFigure}
    \begin{tikzpicture}
		\node[wrapperNode] (wrapper) {Wrapper SNARK\\(SuperSpartan + Greyhound)};
		\node[dataNode, above=0.5cm of wrapper, xshift=-2cm] (accNext) {Accumulator\\$final$};
		\node[dataNode, above=0.5cm of wrapper, xshift=2cm] (memLog) {Memory\\operations log};

		\node[dataNode, right=1.5cm of wrapper] (proof) {Final proof\\$\pi_{final}$};
		\draw[arrow] (memLog) -- (wrapper);
		\draw[arrow] (accNext.south) -- (wrapper.north);
		\draw[arrow] (wrapper) -- (proof);
    \end{tikzpicture}

    \caption{Wrapping last folding step into SNARK.}
    \label{fig:snark_wrap}
\end{tikzFigure}
\pagebreak

\subsection{Prover and Verifier Roles}

The system distinguishes between the computational roles of the Prover and the
Verifier, particularly regarding the recursive steps versus the final verification.

\subsubsection{The Prover}

The Prover is responsible for the entire computational workload of the VM. Its duties include:

\begin{itemize}
    \item \textbf{Witness generation:} Running the RISC-V emulator to produce execution traces.
    \item \textbf{Folding:} Computing the non-interactive folding steps to compress the current step's witness into the running accumulator.
    \item \textbf{Proof generation:} Generating the final wrapping proof once the recursion is complete.
\end{itemize}

\subsubsection{The Verifier}

The verification logic exists at two distinct levels:

\begin{enumerate}
    \item \textbf{The circuit verifier (in circuit):} This is the logic
		embedded within $F'$ (the augmented circuit). It does not run on an
		external machine but is simulated by the Prover to generate the proof.
		It verifies the mathematical correctness of the folding mechanism at every step.
    \item \textbf{The final verifier:} This is the external entity (e.g., an
		Ethereum smart contract). It receives the final proof. Its role is to
		verify the succinct proof of the final folded instance.
\end{enumerate}

\section{Cryptographic Primitives}\label{sec:crypto}

The design of this ZkVM represents a synthesis of several breakthroughs in
zero-knowledge cryptography. Rather than relying on a monolithic proof system,
the solution composes these primitives to instantiate IVC using a folding
scheme. This layered approach allows the system to inherit the efficiency of
folding for the recursive steps while maintaining the post-quantum security
guarantees provided by lattice-based assumptions. This section defines the
specific cryptographic building blocks selected for the implementation.

\subsection{Incrementally Verifiable Computation (IVC)}
The foundational theoretical model for this ZkVM is IVC, introduced by Valiant
\cite{ValiantIVC}. IVC enables a single proof to attest to the correct
execution of a long-running computation $y = F^{(n)}(x)$ by recursively
proving that the state at step $i$ is valid and that a valid proof exists for
step $i-1$. RISC-V execution traces of unbounded length perfectly align with
this model.

\subsection{Folding schemes and Nova}
To make IVC practical, this work utilizes the concept of \textit{Folding
schemes} as introduced in the Nova system \cite{Nova}. Unlike traditional
recursion, where a circuit must fully verify a SNARK at every step, folding
allows the prover to compress two instances of the same relation (one
representing the current step and one representing the accumulator) into a
single instance. The cryptographic cost of folding is negligible compared to
SNARK verification.

\subsection{HyperNova and Customizable Constraint Systems (CCS)}
While Nova relies on R1CS (Rank-1 Constraint Systems), describing complex VM
instruction sets in R1CS often leads to inefficient circuits with many
auxiliary variables. To address this, the RISC-V ISA and IVC constraints are
represented as Customizable Constraint System (CCS) \cite{CCS}
CCS generalizes R1CS, allowing for high-degree gates without overhead. This is
advantageous for representing IVC constraints. These check commitments of previous
steps and parts of it's preimage, which can be of high-degree.

\subsection{Lattice-based hardness assumptions}
To achieve post-quantum security, the cryptographic primitives in this work
rely on hardness assumptions over lattices rather than the Discrete Logarithm
Problem (DLP) used in Nova or HyperNova. The security relies on the hardness
of the Shortest Integer Solution (SIS) and Module-SIS problems. These problems
remain hard even in the presence of quantum computers \cite{AjtaiLattices,
Ajtai1998, LatticeTutorial, LatticesInZKP}.

\subsection{LatticeFold}
LatticeFold \cite{LatticeFold} can be though of as a HyperNova \cite{HyperNova},
but with post-quantum guarantees. It utilizes the Module-SIS \cite{MSIS}
problem to construct Ajtai vector commitment scheme. Unlike DLP-based folding,
the challenge in LatticeFold is the growth of the witness norm during folding
steps. To maintain the binding property of the commitments, the protocol
incorporates a sum-check range proof to ensure the folded witness remains
within a small, predefined norm bound. This allows the scheme to operate
over small prime fields while providing $O(\log n)$ proof size and achieving
transparency, as no trusted setup is required.

\subsection{The wrapping SNARK SuperSpartan + Greyhound}
While LatticeFold allows for efficient recursion, the final artifact is a
large lattice-based accumulator that is expensive to verify directly on-chain.
To compress this into a succinct proof, a wrapping SNARK is employed.
This wrapper is constructed by combining the \textbf{SuperSpartan} \cite{HyperNova}
IOP, which verifies the satisfiability of the CCS relation, with
\textbf{Greyhound} \cite{Greyhound}, a lattice-based PCS with polylogarithmic
verification complexity.

\subsection{Future optimization - LatticeFold+}
It is noted that a newer iteration of the folding scheme, LatticeFold+
\cite{LatticeFoldPlus}, has recently been proposed. LatticeFold+ introduces
purely algebraic range proofs and double commitments, which reduce the prover
overhead by eliminating the need for bit decomposition during witness norm
management. However, at the time of system design, the available libraries for
LatticeFold+ did not support CCS constraints. Thus, this work utilizes the
standard LatticeFold protocol. The architecture is modular, allowing for the
backend to be upgraded to LatticeFold+ in future iterations to further
optimize proving time.

\section{Designing the RISC-V circuit ($F$)}\label{sec:riscv_circuit}

This section details the construction of the step circuit $F$, which encodes
the transition function of the RISC-V VM according to RISC-V ISA \cite{RISCV}.
The design targets a 32 bit architecture, with 1MB of RAM.

\subsection{Field representations and arithmetization}

The target architecture is a 32 bit RISC-V machine. To represent the state of
this machine within the cryptographic proof system, the Goldilocks field is
used. The Goldilocks prime is defined as $p = 2^{64} - 2^{32} + 1$. Since $p >
2^{32}$, a single field element can losslessly represent any 32 bit register
value or memory address without overflow during standard representation.

The LatticeFold protocol operates over cyclotomic rings. A Goldilocks field
element is mapped into the ring $R_q$ using a Number Theoretic Transform (NTT)
representation, where the base field is a degree-3 extension of the Goldilocks
field, and the NTT form consists of 8 components.

Arithmetization is process of converting numbers, with which the VM works,
captured in the execution trace, into the cyclotomic ring Goldilocks elements.

\subsection{State representation}

The execution state at any step $i$ is encapsulated by the tuple $z_i$, which
contains the following components:

\begin{itemize}
    \item \textbf{Program counter ($pc_i$):} A 32 bit integer indicating the address of the next instruction.
    \item \textbf{Registers:} An array of 32 general purpose 32 bit registers.
    \item \textbf{Memory state:} Represented by the root of a Merkle tree covering the machine's RAM. The system models 1MB of RAM, divided into 256 pages, with each page containing 256 words (1024 bytes).
    \item \textbf{Memory log:} A commitment to the vector of memory operations performed up to step $i$.
\end{itemize}

The initial state $z_0$ serves as a public anchor for the computation. Its
commitment $z_{0\_\text{comm}}$ binds the proof to a specific ELF binary
(represented by a \texttt{code\_comm} Merkle root), the entrypoint, and the
initial zeroed state of memory and registers. All of these values are public,
known to both prover and verifier, which means, they do not have to be recomputed
and constrained by the prover nor inside the circuit.

\subsection{Instruction decoding and execution}

For each step, the circuit $F$ enforces valid transitions between $z_{i-1}$
and $z_i$. This process involves the following constraints:

\begin{enumerate}
    \item \textbf{Instruction fetch:} The circuit verifies that the
		instruction executed corresponds to the value stored at $pc_{i-1}$.
		This is enforced by verifying a Merkle proof against the static
		\texttt{code\_comm} root derived from the ELF binary.
    \item \textbf{Decoding:} The 32 bit instruction word is decomposed to
		extract the opcode, source registers ($rs1, rs2$), destination
		register ($rd$), and immediate values, according to the RISC-V ISA \cite{RISCV}.
    \item \textbf{Execution logic:} Based on the decoded opcode, the circuit
		enforces the semantic logic of the instruction.
    \item \textbf{State update:} The circuit constrains the output state
		$z_i$. For arithmetic instructions, this involves updating the
		destination register. For branch instructions, it involves updating
		the $pc$.
\end{enumerate}

\subsection{Memory consistency checks}

Memory consistency ensures that a load operation at step $i$ returns the value
written by the most recent store operation to that address. The verification of
the memory consistency is deferred until the end, when all memory read/write logs
have been collected and the consistency can be proven with one check.

When a load or store instruction is executed:

\begin{enumerate}
    \item \textbf{Operation capture:} The circuit captures the operation,
		which contains the cycle count $i$, the address, the value, and a
		boolean flag indicating a write operation.
    \item \textbf{Log update:} This operation is appended to the memory log.
		Within $F$, this is enforced by updating the Poseidon2 commitment to
		the log vector.
    \item \textbf{Page validation:} For store operations, the circuit
		additionally verifies a Merkle proof for the memory page being
		modified, calculates the new page root, and updates the memory Merkle
		root in the state $z_i$.
\end{enumerate}

The memory log is not fully verified against the register state at every step.
Instead, the correctness of the read/write history is verified in the final
wrapping SNARK (discussed in Section \ref{sec:crypto}) using a permutation
argument on the complete vector of operations collected throughout the execution.
This is discussed in more detail in Section \ref{sec:memory_check}.

% 3.4 The Recursive Mechanism (\(F'\)):
% 	- IVC Integrity: How the current step enforces that the previous step was valid.
% 	- The NIFS Verifier Gadget: Describe the circuit that runs inside the SNARK that verifies the lattice folding math.
% 	- Error Handling: What happens if the program crashes or halts?
% \section{Recursive Composition ($F'$)}\label{sec:recursive_mechanism}
%     \subsection{Enforcing IVC Integrity}
%     \subsection{The On-Circuit NIFS Verifier}
    % How the folding is checked inside the circuit

\chapter{Solution Design}\label{chap:design}

This chapter details the architectural and cryptographic design of the
proposed lattice-based RISC-V ZkVM. It is structured to first
establish the system's high-level architecture \ref{sec:arch}, describing the
lifecycle of a proof from high-level Rust code to a finalized succinct
argument. Following this, the specific cryptographic primitives are defined
\ref{sec:crypto}, selecting the LatticeFold folding scheme \cite{LatticeFold}
as the core recursion engine, while identifying Greyhound \cite{Greyhound} as
the necessary wrapping SNARK for final verification. The design then proceeds
to the construction of the RISC-V step circuit $F$ \ref{sec:riscv_circuit},
detailing how 32 bit integer arithmetic is arithmetized into the small fields
required by lattice schemes using CCS \cite{CCS}. Finally, the recursive
composition mechanism $F'$ is defined \ref{sec:recursive_mechanism}, outlining
how IVC \cite{ValiantIVC} is enforced to prove the integrity of long running computations.

\section{High level Architecture}\label{sec:arch}

The proposed system architecture implements a post-quantum ZkVM capable of
proving the correct execution of arbitrary RISC-V programs. The design
leverages IVC to break down the execution of a program into individual steps.
To instantiate IVC a folding scheme LatticeFold \cite{LatticeFold} is used,
which recursively folds steps into a single, constant-sized cryptographic object.

The architecture is designed to support the 32-bit RISC-V instruction set
(specifically the \texttt{rv32imac} extensions). Due to the proof-of-concept
nature of this implementation, a subset of opcodes is supported, sufficient to
test the viability of a lattice-based ZkVM.

\subsection{The ZkVM IVC}

The lifecycle of a proof within this system proceeds through a pipeline of
transformation, execution, and cryptographic accumulation, as illustrated in
Figure \ref{fig:execution_flow}. This workflow is defined by the following stages:


\begin{enumerate}
    \item \textbf{Compilation and loading:} A program written in a high-level
		language (e.g., Rust) is compiled into a standard RISC-V ELF binary.
		This binary is loaded into the ZkVM emulator.
    
    \item \textbf{Execution and trace generation:} The emulator executes the
		program one instruction at a time. For every step $i$, the system
		captures a comprehensive \textit{Execution Trace}. This trace
		encapsulates the exact state transition of the machine.
		Mathematically, the trace for step $i$, denoted as $\mathcal{T}_i$, contains:
    \begin{itemize}
        \item \textbf{Cycle count:} The global step counter.
        \item \textbf{Input state:} The Program Counter ($PC$) and the state of all 32 general-purpose registers before execution.
        \item \textbf{Output state:} The $PC$ and register states after execution.
        \item \textbf{Decoded instruction:} The raw binary instruction broken down into its opcode, operands, and immediate values.
        \item \textbf{Side effects:} A set of flags indicating arithmetic overflows, branching behavior (jump targets), and memory operations (address, value, and read/write flags).
    \end{itemize}

    \item \textbf{Arithmetization and witness generation:} The raw data from
		$\mathcal{T}_i$ is transformed into a vector of lattice field elements
		$\mathbb{Z}_q$. This vector serves as the \textit{witness} for the
		constraint system. The logic verifying the transition from input state
		to output state based on the decoded instruction defines the
		\textbf{Step circuit}, denoted as $F$.

    \item \textbf{Folding (the augmented circuit $F'$):} To achieve
		IVC, the step circuit $F$ is embedded inside a larger augmented
		circuit, $F'$. This circuit is responsible for the recursive logic.
		For a step $i$, $F'$ performs the following operations:
    \begin{enumerate}
        \item \textbf{IVC integrity checks:} It recalculates the commitment to
			the previous step's data, ensuring the chain of computation is
			unbroken. This follows the IVC patterns established in Nova
			\cite{Nova} and HyperNova \cite{HyperNova}.
        \item \textbf{Folding verification:} It constrains the LatticeFold
			verifier. This enforces that the folding of step $i-1$ into the
			running accumulator was performed correctly.
        \item \textbf{Step verification:} It enforces the constraints of $F$,
			guaranteeing that the RISC-V instruction at step $i$ was executed
			correctly according to the ISA.
    \end{enumerate}

    \item \textbf{Memory logging:} If the instruction execution triggers a
		memory operation (load or store), this side effect is captured and
		appended to a global vector of memory operations. Unlike register
		transitions, memory consistency is not fully proven within $F'$;
		instead, it is verified via a deferred memory consistency check after
		the execution concludes.

	\item \textbf{Final wrapping:} Once the program halts, the system holds a
		single folded instance-witness pair (the accumulator). To produce a
		succinct proof suitable for blockchain verification, this large
		lattice-based artifact is wrapped in a final SNARK as depicted in Figure \ref{fig:snark_wrap}. 
		This wrapper utilizes the SuperSpartan IOP \cite{HyperNova} to prove the validity of the folded
		CCS instance, combined with the Greyhound \cite{Greyhound} PCS to
		ensure post-quantum security and succinct verification.
\end{enumerate}

\begin{tikzFigure}
    \begin{tikzpicture}
		\node[dataNode] (rust) {Rust source};
		\node[processNode, right=0.8cm of rust] (compiler) {Compiler\\(LLVM/GCC)};
		\node[dataNode, right=0.8cm of compiler] (elf) {RISC-V\\binary};

		\draw[arrow] (rust) -- (compiler);
		\draw[arrow] (compiler) -- (elf);

		\node[processNode, below=1cm of elf] (vm) {ZkVM\\emulator};
		\draw[arrow] (elf) -- (vm);

		\node[dataNode, below=1cm of vm] (witness) {Witness $w_i$\\($\mathbb{Z}_q$ Matrix)};
		\draw[arrow] (vm) -- node[midway, right] {Exec instruction $i$} (witness);

		\node[processNode, below left=1.5cm and 0.5cm of witness] (stepCircuit) {Step circuit $F$\\ (RISC-V logic)};
		\node[processNode, below=0.5cm of stepCircuit] (ivcChainCheck) {IVC chain\\check};
		\node[processNode, below=0.5cm of ivcChainCheck] (foldVerifier) {LatticeFold\\verifier};

		\node[augmentedFrame, fit=(stepCircuit) (foldVerifier)] (augCircuit) {};
		\node[anchor=south east] at (augCircuit.north east) {\textbf{Augmented circuit $F'$}};

		\node[dataNode, left=1.5cm of augCircuit, yshift=-1.5cm] (accPrev) {Accumulator\\$i-1$};
		\node[dataNode, left=1.5cm of augCircuit] (ivcProofPrev) {Folding proof\\of step $i-1$};
		\node[dataNode, left=1.5cm of augCircuit, yshift=1.5cm] (ivcHPrev) {IVC commitment $h$\\to step $i-1$};

		\node[dataNode, right=1.5cm of augCircuit, yshift=-1.5cm] (accNext) {Accumulator\\$i$};
		\node[dataNode, right=1.5cm of augCircuit] (ivcProofNext) {Folding proof\\of step $i$};
		\node[dataNode, right=1.5cm of augCircuit, yshift=1.5cm] (ivcHNext) {IVC commitment $h$\\to step $i$};

		\draw[arrow] (witness.south) -- (stepCircuit.east);
		\draw[arrow] (accPrev.east) -- (accPrev -| augCircuit.west);
		\draw[arrow] (ivcProofPrev.east) -- (ivcProofPrev -| augCircuit.west);
		\draw[arrow] (ivcHPrev.east) -- (ivcHPrev -| augCircuit.west);

		\draw[arrow] (augCircuit.east) -- (accNext.west);
		\draw[arrow] (augCircuit.east) -- (ivcProofNext.west);
		\draw[arrow] (augCircuit.east) -- (ivcHNext.west);

		\node[dataNode, below=1cm of augCircuit, xshift=0.5cm] (memLog) {Memory\\operations log};
		\draw[dashedArrow] (stepCircuit.west) -- ++(-1.5,-1) -- ++(0,-1.5) -- (memLog.west) node[midway, left] {\scriptsize Memory logs};

		\node[left=0.8cm of ivcProofPrev] (dotsStart) {\Large$\dots$};
		\draw[dashedArrow] (dotsStart) -- (accPrev);
		\draw[dashedArrow] (dotsStart) -- (ivcHPrev);
		\draw[dashedArrow] (dotsStart) -- (ivcProofPrev);

		\node[right=0.8cm of ivcProofNext] (dotsEnd) {\Large$\dots$};
		\draw[dashedArrow] (accNext) -- (dotsEnd);
		\draw[dashedArrow] (ivcHNext) -- (dotsEnd);
		\draw[dashedArrow] (ivcProofNext) -- (dotsEnd);
    \end{tikzpicture}

	\caption{Execution flow of the lattice-based RISC-V ZkVM IVC instantiation.}
	\label{fig:execution_flow}
\end{tikzFigure}

\begin{tikzFigure}
    \begin{tikzpicture}
		\node[wrapperNode] (wrapper) {Wrapper SNARK\\(SuperSpartan + Greyhound)};
		\node[dataNode, above=0.5cm of wrapper, xshift=-2cm] (accNext) {Accumulator\\$final$};
		\node[dataNode, above=0.5cm of wrapper, xshift=2cm] (memLog) {Memory\\operations log};

		\node[dataNode, right=1.5cm of wrapper] (proof) {Final proof\\$\pi_{final}$};
		\draw[arrow] (memLog) -- (wrapper);
		\draw[arrow] (accNext.south) -- (wrapper.north);
		\draw[arrow] (wrapper) -- (proof);
    \end{tikzpicture}

    \caption{Wrapping last folding step into SNARK.}
    \label{fig:snark_wrap}
\end{tikzFigure}
\pagebreak

\subsection{Prover and Verifier Roles}

The system distinguishes between the computational roles of the Prover and the
Verifier, particularly regarding the recursive steps versus the final verification.

\subsubsection{The Prover}

The Prover is responsible for the entire computational workload of the VM. Its duties include:

\begin{itemize}
    \item \textbf{Witness generation:} Running the RISC-V emulator to produce execution traces.
    \item \textbf{Folding:} Computing the non-interactive folding steps to compress the current step's witness into the running accumulator.
    \item \textbf{Proof generation:} Generating the final wrapping proof once the recursion is complete.
\end{itemize}

\subsubsection{The Verifier}

The verification logic exists at two distinct levels:

\begin{enumerate}
    \item \textbf{The circuit verifier (in circuit):} This is the logic
		embedded within $F'$ (the augmented circuit). It does not run on an
		external machine but is simulated by the Prover to generate the proof.
		It verifies the mathematical correctness of the folding mechanism at every step.
    \item \textbf{The final verifier:} This is the external entity (e.g., an
		Ethereum smart contract). It receives the final proof. Its role is to
		verify the succinct proof of the final folded instance.
\end{enumerate}

\section{Cryptographic Primitives}\label{sec:crypto}

The design of this ZkVM represents a synthesis of several breakthroughs in
zero-knowledge cryptography. Rather than relying on a monolithic proof system,
the solution composes these primitives to instantiate IVC using a folding
scheme. This layered approach allows the system to inherit the efficiency of
folding for the recursive steps while maintaining the post-quantum security
guarantees provided by lattice-based assumptions. This section defines the
specific cryptographic building blocks selected for the implementation.

\subsection{Incrementally Verifiable Computation (IVC)}
The foundational theoretical model for this ZkVM is IVC, introduced by Valiant
\cite{ValiantIVC}. IVC enables a single proof to attest to the correct
execution of a long-running computation $y = F^{(n)}(x)$ by recursively
proving that the state at step $i$ is valid and that a valid proof exists for
step $i-1$. RISC-V execution traces of unbounded length perfectly align with
this model.

\subsection{Folding schemes and Nova}
To make IVC practical, this work utilizes the concept of \textit{Folding
schemes} as introduced in the Nova system \cite{Nova}. Unlike traditional
recursion, where a circuit must fully verify a SNARK at every step, folding
allows the prover to compress two instances of the same relation (one
representing the current step and one representing the accumulator) into a
single instance. The cryptographic cost of folding is negligible compared to
SNARK verification.

\subsection{HyperNova and Customizable Constraint Systems (CCS)}
While Nova relies on R1CS (Rank-1 Constraint Systems), describing complex VM
instruction sets in R1CS often leads to inefficient circuits with many
auxiliary variables. To address this, the RISC-V ISA and IVC constraints are
represented as Customizable Constraint System (CCS) \cite{CCS}
CCS generalizes R1CS, allowing for high-degree gates without overhead. This is
advantageous for representing IVC constraints. These check commitments of previous
steps and parts of it's preimage, which can be of high-degree.

\subsection{Lattice-based hardness assumptions}
To achieve post-quantum security, the cryptographic primitives in this work
rely on hardness assumptions over lattices rather than the Discrete Logarithm
Problem (DLP) used in Nova or HyperNova. The security relies on the hardness
of the Shortest Integer Solution (SIS) and Module-SIS problems. These problems
remain hard even in the presence of quantum computers \cite{AjtaiLattices,
Ajtai1998, LatticeTutorial, LatticesInZKP}.

\subsection{LatticeFold}
LatticeFold \cite{LatticeFold} can be though of as a HyperNova \cite{HyperNova},
but with post-quantum guarantees. It utilizes the Module-SIS \cite{MSIS}
problem to construct Ajtai vector commitment scheme. Unlike DLP-based folding,
the challenge in LatticeFold is the growth of the witness norm during folding
steps. To maintain the binding property of the commitments, the protocol
incorporates a sum-check range proof to ensure the folded witness remains
within a small, predefined norm bound. This allows the scheme to operate
over small prime fields while providing $O(\log n)$ proof size and achieving
transparency, as no trusted setup is required.

\subsection{The wrapping SNARK SuperSpartan + Greyhound}
While LatticeFold allows for efficient recursion, the final artifact is a
large lattice-based accumulator that is expensive to verify directly on-chain.
To compress this into a succinct proof, a wrapping SNARK is employed.
This wrapper is constructed by combining the \textbf{SuperSpartan} \cite{HyperNova}
IOP, which verifies the satisfiability of the CCS relation, with
\textbf{Greyhound} \cite{Greyhound}, a lattice-based PCS with polylogarithmic
verification complexity.

\subsection{Future optimization - LatticeFold+}
It is noted that a newer iteration of the folding scheme, LatticeFold+
\cite{LatticeFoldPlus}, has recently been proposed. LatticeFold+ introduces
purely algebraic range proofs and double commitments, which reduce the prover
overhead by eliminating the need for bit decomposition during witness norm
management. However, at the time of system design, the available libraries for
LatticeFold+ did not support CCS constraints. Thus, this work utilizes the
standard LatticeFold protocol. The architecture is modular, allowing for the
backend to be upgraded to LatticeFold+ in future iterations to further
optimize proving time.

% 3.3 The RISC-V Virtual Machine (\(F\)):
% 	- Execution Trace Generation: How binary instructions are turned into a matrix of values.
% 	- Arithmetization (CCS):
% 		- How to represent 32-bit/64-bit logic in the specific lattice field (likely a small field like \(\mathbb{Z}_q\)).
% 		- Decomposition strategies for arithmetic operations.
% 	- Memory Consistency:
% 		- How to prove that read(addr) returns the last write(addr). (Usually done via permutation arguments or lookup arguments adapted for lattices).
% \section{Designing the RISC-V Circuit ($F$)}\label{sec:riscv_circuit}
%     \subsection{Execution Trace Generation}
%         % From Binary to Matrix
%     \subsection{Arithmetization using CCS}
%         % Efficient encoding of opcodes and registers in Lattice fields
%     \subsection{Memory Consistency Checks}
        % Permutation arguments for RAM

% 3.4 The Recursive Mechanism (\(F'\)):
% 	- IVC Integrity: How the current step enforces that the previous step was valid.
% 	- The NIFS Verifier Gadget: Describe the circuit that runs inside the SNARK that verifies the lattice folding math.
% 	- Error Handling: What happens if the program crashes or halts?
% \section{Recursive Composition ($F'$)}\label{sec:recursive_mechanism}
%     \subsection{Enforcing IVC Integrity}
%     \subsection{The On-Circuit NIFS Verifier}
    % How the folding is checked inside the circuit
